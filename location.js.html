<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: location.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: location.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * A location is an object that defines a port or a node in the graph. A location can be one of the following:
 * - id,
 * - compound path
 * - node object
 * - port object.
 */

import curry from 'lodash/fp/curry'
import merge from 'lodash/fp/merge'
import {nodeByPath, idToPath, nodes} from './graph/internal'
import {isPort} from './port'
import {isValid as isNode, equal, id, isID, isReference} from './node'
import {rest, prefix} from './compoundPath'

/** A port notation can have every of the other notations for the node and as such
 * it is necessary to check first if it is a port notation. The symbol '@' is only used in
 * port notations.
 */
function isPortNotation (str) {
  return str.indexOf('@') !== -1
}

function isCompoundPathNotation (str) {
  return !isPortNotation(str) &amp;&amp; str[0] === '»'
}

function isComponent (str) {
  return !isPortNotation(str) &amp;&amp; str[0] === '/'
}

function isIndex (str) {
  return !isPortNotation(str) &amp;&amp; str[0] === '#'
}

function isRoot (str) {
  return str === ''
}

/*
function isName (str) {
  return !isPortNotation(str) &amp;&amp; !isIndex(str) &amp;&amp; !isCompoundPathNotation(str)
}
*/

function parsePortNotation (port) {
  var split = port.split('@')
  if (split[1] === '') {
    throw new Error('Invalid port notation. Port notation does not contain a port. Parsed port: ' + port)
  }
  return merge(fromString(split[0], false), {type: 'location', locType: 'port', port: split[1]})
}

/**
 * Converts a compound path string into its array representation. The seperate parts must be divided by a '»'.
 * @param {String} compoundPathStr A string reperesenting the compound path divded by '»'.
 * @returns {String[]} An array of node IDs representing the compound path.
 */
export function parseCompoundPath (compoundPathStr) {
  if (compoundPathStr.indexOf('»') === -1) return [compoundPathStr]
  return compoundPathStr.split('»').slice(1)
}

/** Creates a location object from the string representation */
function fromString (str, allowsPorts = true) {
  if (isPortNotation(str)) {
    if (!allowsPorts) {
      throw new Error('Found unexpected port notation. Do you have multiple @\'s in your location string?')
    }
    return parsePortNotation(str)
  } else if (isCompoundPathNotation(str)) {
    return {type: 'location', locType: 'node', path: parseCompoundPath(str)}
  } else if (isComponent(str)) {
    return {type: 'query', queryType: 'component', query: str.slice(1)}
  } else if (isIndex(str)) {
    return {type: 'location', locType: 'node', index: str}
  } else if (isRoot(str)) {
    return {type: 'location', locType: 'node', path: []}
  } else {
    return {type: 'location', locType: 'node', path: [str]}
  }
}

function idify (path, graph) {
  if (path.length === 0) return path
  if (path.every((p) => isID(p))) return path
  var node = nodes(graph).filter(equal(path[0]))[0]
  if (!node) {
    if (equal(path[0], graph)) {
      return [id(graph)].concat(idify(rest(path), graph))
    }
    return
  }
  return [id(node)].concat(idify(rest(path), node))
}

function locPath (loc, graph) {
  var graphPath = graph.path
  if (loc.path) {
    let idPath = idify(loc.path, graph)
    return (idPath) ? prefix(idPath, graphPath) : undefined
  } else if (loc.name) {
    // best guess is that the node is at the root level...
    let idPath = idify([loc.name], graph)
    return (idPath) ? prefix(idPath, graphPath) : undefined
  } else if (loc.index) {
    var nodePath = idToPath(loc.index, graph)
    if (!nodePath) {
      throw new Error('Unable to locate node with id: ' + loc.index + '.')
    }
    return prefix(nodePath, graphPath)
  } else {
    throw new Error('Unable to process location. Not enough information to find node in the graph.')
  }
}

function fullLocation (loc, graph) {
  if (loc.type === 'query') return loc
  var path = locPath(loc, graph)
  var node = nodeByPath(path, graph) || {}
  return {
    type: 'location',
    locType: loc.locType,
    path,
    index: (loc.index) ? loc.index : node.id,
    name: (loc.name) ? loc.name : node.name,
    port: loc.port
  }
}

/**
 * Create a new location from a given object
 * @param loc Any processable form of location. TODO: list alle formats.
 * @param {PortGraph} graph The graph in which the location is valid.
 * @returns {Location} A location object
 */
export function location (loc, graph) {
  if (typeof (loc) === 'string') {
    return fullLocation(fromString(loc), graph)
  } else if (Array.isArray(loc)) {
    return fullLocation({type: 'location', locType: 'node', path: loc}, graph)
  } else if (typeof (loc) === 'object' &amp;&amp; isPort(loc)) {
    var locObj = location(loc.node, graph)
    var merged = (locObj.type === 'query')
      ? merge({locType: 'port', port: loc.port}, location(loc.node, graph))
      : merge(location(loc.node, graph), {type: 'location', locType: 'port', port: loc.port})
    return fullLocation(merged, graph)
  } else if (typeof (loc) === 'object' &amp;&amp; loc.id) {
    return fullLocation(fromString(loc.id), graph)
  } else if (typeof (loc) === 'object' &amp;&amp; loc.name) {
    return fullLocation(fromString(loc.name), graph)
  } else if (typeof (loc) === 'object' &amp;&amp; loc.path) {
    return fullLocation({type: 'location', locType: 'node', path: loc.path}, graph)
  } else {
    return {type: 'location', locType: 'invalid'}
//    throw new Error('Unknown location type: ' + JSON.stringify(loc))
  }
}

/**
 * Create a query function for a location.
 * @param {Location} loc A location identifier.
 * @param {PortGraph} graph The graph in which the location is valid.
 * @returns {function} A function that takes another location or location identifier
 * and compares it to the specified location `loc`. See `Location.identifies`.
 */
export function query (loc, graph) {
  return identifies(location(loc, graph))
}

function identifiesNode (loc, node) {
  return (isPort(node) &amp;&amp;
      ((isIndex(node.node) &amp;&amp; loc.index === node.node) ||
      (!isIndex(node.node) &amp;&amp; loc.name === node.node))) ||
    (!isPort(node) &amp;&amp; loc.index === node.id)
}

function identifiesPort (loc, port) {
  return loc.locType === 'port' &amp;&amp; loc.port === port.port &amp;&amp; identifiesNode(loc, port)
}

function isRootNode (n) {
  return typeof (n) === 'object' &amp;&amp; n.path &amp;&amp; n.path.length === 0
}

/**
 * @function
 * @name identifies
 * @description Checks whether a location identifies the given object. This is true if
 * for example the location points to a node and the other object is the node.
 * Or if the other object is simply the ID of the node.
 * It also identifies a node if the location specifies the port. If you don't want
 * this behavior use equals (it is the strict version of identifies).
 * @params {Location} location A location object.
 * @params other Any type that can be a location.
 * @returns True if the location identifies the object stored in other.
 */
export const identifies = curry((loc, other) => {
  if (loc.type === 'query' &amp;&amp; loc.queryType === 'component') {
    if (isReference(other)) {
      return other.ref === loc.query
    }
    if (isPort(other)) {
      return identifies(loc, other.additionalInfo)
    }
    return other.componentId === loc.query
  } else if (loc.locType === 'port' &amp;&amp; isPort(other)) {
    return isPort(other) &amp;&amp; identifiesPort(loc, other)
  } else if (loc.locType === 'node' &amp;&amp; isID(other)) {
    return equal(loc, other)
  } else if (isNode(other) || isRootNode(other) || isPort(other)) {
    return identifiesNode(loc, other)
  } else {
    throw new Error('Unable to identify object type. Checking for: ' + JSON.stringify(loc) + ' object is: ' + JSON.stringify(other))
  }
})

export const toString = (loc) => {
  return JSON.stringify(loc)
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Algorithm.html">Algorithm</a></li><li><a href="module-Component.html">Component</a></li><li><a href="module-CompoundPath.html">CompoundPath</a></li><li><a href="module-Edge.html">Edge</a></li><li><a href="module-Node.html">Node</a></li><li><a href="module-Port.html">Port</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addComponent">addComponent</a></li><li><a href="global.html#addEdge">addEdge</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#addNodeByPath">addNodeByPath</a></li><li><a href="global.html#addNodeIn">addNodeIn</a></li><li><a href="global.html#addNodeTuple">addNodeTuple</a></li><li><a href="global.html#applyChangeSet">applyChangeSet</a></li><li><a href="global.html#applyChangeSetInplace">applyChangeSetInplace</a></li><li><a href="global.html#applyChangeSets">applyChangeSets</a></li><li><a href="global.html#areConnected">areConnected</a></li><li><a href="global.html#atomics">atomics</a></li><li><a href="global.html#blocked">blocked</a></li><li><a href="global.html#childrenOf">childrenOf</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#component">component</a></li><li><a href="global.html#componentIds">componentIds</a></li><li><a href="global.html#components">components</a></li><li><a href="global.html#compound">compound</a></li><li><a href="global.html#compoundify">compoundify</a></li><li><a href="global.html#compounds">compounds</a></li><li><a href="global.html#convertToLambda">convertToLambda</a></li><li><a href="global.html#createConnection">createConnection</a></li><li><a href="global.html#criticalNodes">criticalNodes</a></li><li><a href="global.html#distribute">distribute</a></li><li><a href="global.html#distributeSequential">distributeSequential</a></li><li><a href="global.html#distributeWith">distributeWith</a></li><li><a href="global.html#edge">edge</a></li><li><a href="global.html#edges">edges</a></li><li><a href="global.html#edgesDeep">edgesDeep</a></li><li><a href="global.html#empty">empty</a></li><li><a href="global.html#excludeNode">excludeNode</a></li><li><a href="global.html#flow">flow</a></li><li><a href="global.html#flowCallback">flowCallback</a></li><li><a href="global.html#fromFile">fromFile</a></li><li><a href="global.html#fromJSON">fromJSON</a></li><li><a href="global.html#fromString">fromString</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getMetaKey">getMetaKey</a></li><li><a href="global.html#getNodeMetaKey">getNodeMetaKey</a></li><li><a href="global.html#hasComponent">hasComponent</a></li><li><a href="global.html#hasEdge">hasEdge</a></li><li><a href="global.html#hasNode">hasNode</a></li><li><a href="global.html#identifies">identifies</a></li><li><a href="global.html#idToPath">idToPath</a></li><li><a href="global.html#incidents">incidents</a></li><li><a href="global.html#includePredecessor">includePredecessor</a></li><li><a href="global.html#inIncident">inIncident</a></li><li><a href="global.html#inIncidents">inIncidents</a></li><li><a href="global.html#insertComponent">insertComponent</a></li><li><a href="global.html#insertEdge">insertEdge</a></li><li><a href="global.html#insertNode">insertNode</a></li><li><a href="global.html#isChangeSet">isChangeSet</a></li><li><a href="global.html#isFrom">isFrom</a></li><li><a href="global.html#isomorph">isomorph</a></li><li><a href="global.html#isPortNotation">isPortNotation</a></li><li><a href="global.html#Let">Let</a></li><li><a href="global.html#location">location</a></li><li><a href="global.html#lowestCommonAncestors">lowestCommonAncestors</a></li><li><a href="global.html#mergeNodes">mergeNodes</a></li><li><a href="global.html#meta">meta</a></li><li><a href="global.html#namedFlow">namedFlow</a></li><li><a href="global.html#node">node</a></li><li><a href="global.html#nodeBy">nodeBy</a></li><li><a href="global.html#nodeByPath">nodeByPath</a></li><li><a href="global.html#nodeNames">nodeNames</a></li><li><a href="global.html#nodes">nodes</a></li><li><a href="global.html#nodesBy">nodesBy</a></li><li><a href="global.html#nodesDeep">nodesDeep</a></li><li><a href="global.html#nodesDeepBy">nodesDeepBy</a></li><li><a href="global.html#outIncidents">outIncidents</a></li><li><a href="global.html#parent">parent</a></li><li><a href="global.html#parseCompoundPath">parseCompoundPath</a></li><li><a href="global.html#pointsTo">pointsTo</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#predecessor">predecessor</a></li><li><a href="global.html#predecessors">predecessors</a></li><li><a href="global.html#predecessorsUntil">predecessorsUntil</a></li><li><a href="global.html#predecessorsUpTo">predecessorsUpTo</a></li><li><a href="global.html#query">query</a></li><li><a href="global.html#realizeEdgesForNode">realizeEdgesForNode</a></li><li><a href="global.html#references">references</a></li><li><a href="global.html#removeComponent">removeComponent</a></li><li><a href="global.html#removeEdge">removeEdge</a></li><li><a href="global.html#removeMetaKey">removeMetaKey</a></li><li><a href="global.html#removeNode">removeNode</a></li><li><a href="global.html#removeNodeMetaKey">removeNodeMetaKey</a></li><li><a href="global.html#rePath">rePath</a></li><li><a href="global.html#replaceByCall">replaceByCall</a></li><li><a href="global.html#replaceByThunk">replaceByThunk</a></li><li><a href="global.html#replaceNode">replaceNode</a></li><li><a href="global.html#replacePort">replacePort</a></li><li><a href="global.html#sameParents">sameParents</a></li><li><a href="global.html#sameParentsNodes">sameParentsNodes</a></li><li><a href="global.html#sequential">sequential</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setMeta">setMeta</a></li><li><a href="global.html#setMetaKey">setMetaKey</a></li><li><a href="global.html#setNodeMeta">setNodeMeta</a></li><li><a href="global.html#setNodeMetaKey">setNodeMetaKey</a></li><li><a href="global.html#setPortName">setPortName</a></li><li><a href="global.html#successors">successors</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#unCompound">unCompound</a></li><li><a href="global.html#updateComponent">updateComponent</a></li><li><a href="global.html#updateEdge">updateEdge</a></li><li><a href="global.html#updateMetaKey">updateMetaKey</a></li><li><a href="global.html#updateNode">updateNode</a></li><li><a href="global.html#updateNodeMetaKey">updateNodeMetaKey</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Apr 20 2017 22:15:44 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
