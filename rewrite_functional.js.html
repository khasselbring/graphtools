<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: rewrite/functional.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: rewrite/functional.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Rewriting basic structures into functional structures
 */

import curry from 'lodash/fp/curry'
import flatten from 'lodash/fp/flatten'
import * as Graph from '../graph'
import * as Node from '../node'
import {successors, predecessor} from '../graph/connections'
import * as CmpRewrite from './compound'
import {createLambda, createPartial, createFunctionCall} from '../functional/lambda'

const letF = Graph.Let
const distSeq = Graph.distributeSeq
const sequential = Graph.sequential

const createContext = (compound, parent, graph) => {
  return {
    inputs: Node.inputPorts(compound).map((input) => [input, predecessor(input, graph)]),
    outputs: Node.outputPorts(compound).map((output) => [output, successors(output, graph)]),
    parent
  }
}

function extendContext (context) {
  return (lambda, graph, ...cbs) => {
    const cb = Graph.flowCallback(cbs)
    return cb(Object.assign({lambda}, context), graph)
  }
}

function createLambdaNode (compound, parent, context) {
  return (graph, ...cbs) => {
    const cb = Graph.flowCallback(cbs)
    return sequential([Graph.addNodeIn(parent, createLambda(compound)), extendContext(context), cb])(graph)
  }
}

/**
 * @function
 * @name convertToLambda
 * @description
 * Create a lambda node that contains the given subset of nodes. It will not connect the inputs and
 * outputs use createCall for that.
 * @param {Location} parent The parent of the subset.
 * @param {Array&lt;Location>} subset A subset of nodes in the graph that should be included in the lambda node.
 * @param {Portgraph} graph The graph
 * @param {Callback} [cb] A callback that is called after the lambda node is created. The context
 * will be an object that contains the lambda node, the predecessors of the subset and the successors of that subset. I.e.
 * the context object will look like this:
 *
 * ```
 * {
 *   "lambda": "&lt;The lambda node>",
 *   "inputs": [[&lt;inputPort>, &lt;predecessor>], ...],
 *   "outputs": [[&lt;outputPort, [&lt;successors>, ...]],...]
 * }
 * ```
 *
 * The graph is the new graph which includes the lambda nodes and in which the subset has been removed. The return
 * value of the callback function must be a graph (i.e. a graph in which you connect the remaining parts).
 * @returns {Portgraph} A new graph that replaced the subset with a lambda node. If a callback is given, the callback
 * is applied to the graph before `convertToLambda` returns and the return value of that callback is returned.
 */
export const convertToLambda = curry((parent, subset, graph, ...cbs) => {
  const cb = Graph.flowCallback(cbs)
  return CmpRewrite.compoundify(parent, subset, graph, (compound, compGraph) => {
    const context = createContext(compound, parent, compGraph)
    return Graph.flow(
      Graph.removeNode(compound), // remove the old compound node in the end
      letF(createLambdaNode(compound, parent, context), cb) // create lambda node and pass information to callback
    )(compGraph)
  })
})

function createInputPartialsInternal (inputs, parent, from) {
  return (graph, ...cbs) => {
    const cb = Graph.flowCallback(cbs)
    if (inputs.length > 0) {
      return Graph.addNodeIn(parent, createPartial(), graph, (newPartial, graph) =>
        Graph.flow(
          Graph.addEdge({from: Node.port('fn', from), to: Node.port('inFn', newPartial)}),
          Graph.addEdge({from: inputs[0][1], to: Node.port('value', newPartial)}),
          letF(createInputPartialsInternal(inputs.slice(1), parent, newPartial), cb)
        )(graph))
    }
    return cb(from, graph)
  }
}

export const createInputPartials = curry((context, graph, ...cbs) => {
  return createInputPartialsInternal(context.inputs, context.parent, context.lambda)(graph, ...cbs)
})

const createCall = ([context, last], graph) =>
  Graph.Let(Graph.addNode(createFunctionCall(context.outputs)), (call, graph) =>
    Graph.flow(
      Graph.addEdge({from: Node.port('fn', last), to: Node.port('fn', call)}),
      flatten(context.outputs.map(([port, succ]) =>
        succ.map((s) => Graph.addEdge({from: Node.port(port, call), to: s}))))
    )(graph))(graph)

/**
 * Takes a subset of nodes (all of them must have the same parent) and replaces them
 * by a lambda function, the partial application of their inputs and a call with all
 * outputs connected to the subsets successors.
 * @param {Array&lt;Location>} subset A subset of locations identifying nodes which will be replaced by
 * a lambda call.
 * @param {Portgraph} graph The graph
 * @returns {Portgraph} A new graph in which the subset was replaced by a call to a lambda
 * function.
 */
export const replaceByCall = curry((parent, subset, graph) =>
  replaceByThunk(parent, subset, graph, createCall))

const ternaryPack = (fn) =>
  curry((a, b, graph) => {
    return fn([a, b], graph)
  })

/**
 * Takes a subset of nodes (all of them must have the same parent) and replaces them
 * by a lambda function, the partial application of their inputs It will not call the
 * lambda function and thus their outputs will not be connected. If you want to connect
 * the outputs after the call use replaceByCall. Information about the successors is accessible
 * via the context-callback.
 * @param {Location} parent The parent of the subset.
 * @param {Array&lt;Location>} subset A subset of locations identifying nodes which will be replaced by
 * a lambda call.
 * @param {Portgraph} graph The graph
 * @param {Callback} [contextCallback] A context callback that is called after the thunk is created.
 * It has the signature [Context x Node] x Graph -> Graph . The context contains information about the
 * lambda node, and the successors. The second parameter is the last partial/lambda node that
 * outputs the thunk. The callback must return a graph which then will be the return value of this
 * function (replaceByThunk). The context object has the following structure:
 *
 * ```
 * {
 *   "lambda": "&lt;The lambda node>",
 *   "inputs": [[&lt;inputPort>, &lt;predecessor>], ...],
 *   "outputs": [[&lt;outputPort, [&lt;successors>, ...]],...]
 * }
 * ```
 *
 * The predecessors are already connected to create a thunk.
 * @returns {Portgraph} A new graph in which the subset was replaced by a call to a lambda
 * function. **Caution**: The new graph will not connect the output of the lambda function
 * use the context-callback to connect the outputs.
 * @example &lt;caption>replaceByCall implementation&lt;/caption>
 * // create call is a context-callback that creates a call node and connects it properly
 * export const replaceByCall = curry((subset, graph) =>
 *   replaceByThunk(subset, graph, createCall))
 * @example &lt;caption>Log the not connected successors as an array.&lt;/caption>
 * replaceByThunk(subset, graph, curry((context, last, graph) => {
 *   console.log(flatten(context.outputs.map((o) => o[1])))
 * }))
 */
export const replaceByThunk = curry((parent, subset, graph, ...cbs) =>
  convertToLambda(parent, subset, graph, distSeq([createInputPartials, ternaryPack(Graph.flowCallback(cbs))])))
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Algorithm.html">Algorithm</a></li><li><a href="module-Component.html">Component</a></li><li><a href="module-CompoundPath.html">CompoundPath</a></li><li><a href="module-Edge.html">Edge</a></li><li><a href="module-Node.html">Node</a></li><li><a href="module-Port.html">Port</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addComponent">addComponent</a></li><li><a href="global.html#addEdge">addEdge</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#addNodeByPath">addNodeByPath</a></li><li><a href="global.html#addNodeIn">addNodeIn</a></li><li><a href="global.html#addNodeTuple">addNodeTuple</a></li><li><a href="global.html#applyChangeSet">applyChangeSet</a></li><li><a href="global.html#applyChangeSetInplace">applyChangeSetInplace</a></li><li><a href="global.html#applyChangeSets">applyChangeSets</a></li><li><a href="global.html#areConnected">areConnected</a></li><li><a href="global.html#atomics">atomics</a></li><li><a href="global.html#blocked">blocked</a></li><li><a href="global.html#childrenOf">childrenOf</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#component">component</a></li><li><a href="global.html#componentIds">componentIds</a></li><li><a href="global.html#components">components</a></li><li><a href="global.html#compound">compound</a></li><li><a href="global.html#compoundify">compoundify</a></li><li><a href="global.html#compounds">compounds</a></li><li><a href="global.html#convertToLambda">convertToLambda</a></li><li><a href="global.html#createConnection">createConnection</a></li><li><a href="global.html#criticalNodes">criticalNodes</a></li><li><a href="global.html#distribute">distribute</a></li><li><a href="global.html#distributeSequential">distributeSequential</a></li><li><a href="global.html#distributeWith">distributeWith</a></li><li><a href="global.html#edge">edge</a></li><li><a href="global.html#edges">edges</a></li><li><a href="global.html#edgesDeep">edgesDeep</a></li><li><a href="global.html#empty">empty</a></li><li><a href="global.html#excludeNode">excludeNode</a></li><li><a href="global.html#flow">flow</a></li><li><a href="global.html#flowCallback">flowCallback</a></li><li><a href="global.html#fromFile">fromFile</a></li><li><a href="global.html#fromJSON">fromJSON</a></li><li><a href="global.html#fromString">fromString</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getMetaKey">getMetaKey</a></li><li><a href="global.html#getNodeMetaKey">getNodeMetaKey</a></li><li><a href="global.html#hasComponent">hasComponent</a></li><li><a href="global.html#hasEdge">hasEdge</a></li><li><a href="global.html#hasNode">hasNode</a></li><li><a href="global.html#identifies">identifies</a></li><li><a href="global.html#idToPath">idToPath</a></li><li><a href="global.html#incidents">incidents</a></li><li><a href="global.html#includePredecessor">includePredecessor</a></li><li><a href="global.html#inIncident">inIncident</a></li><li><a href="global.html#inIncidents">inIncidents</a></li><li><a href="global.html#insertComponent">insertComponent</a></li><li><a href="global.html#insertEdge">insertEdge</a></li><li><a href="global.html#insertNode">insertNode</a></li><li><a href="global.html#isChangeSet">isChangeSet</a></li><li><a href="global.html#isFrom">isFrom</a></li><li><a href="global.html#isomorph">isomorph</a></li><li><a href="global.html#isPortNotation">isPortNotation</a></li><li><a href="global.html#Let">Let</a></li><li><a href="global.html#location">location</a></li><li><a href="global.html#lowestCommonAncestors">lowestCommonAncestors</a></li><li><a href="global.html#mergeNodes">mergeNodes</a></li><li><a href="global.html#meta">meta</a></li><li><a href="global.html#namedFlow">namedFlow</a></li><li><a href="global.html#node">node</a></li><li><a href="global.html#nodeBy">nodeBy</a></li><li><a href="global.html#nodeByPath">nodeByPath</a></li><li><a href="global.html#nodeNames">nodeNames</a></li><li><a href="global.html#nodes">nodes</a></li><li><a href="global.html#nodesBy">nodesBy</a></li><li><a href="global.html#nodesDeep">nodesDeep</a></li><li><a href="global.html#nodesDeepBy">nodesDeepBy</a></li><li><a href="global.html#outIncidents">outIncidents</a></li><li><a href="global.html#parent">parent</a></li><li><a href="global.html#parseCompoundPath">parseCompoundPath</a></li><li><a href="global.html#pointsTo">pointsTo</a></li><li><a href="global.html#port">port</a></li><li><a href="global.html#predecessor">predecessor</a></li><li><a href="global.html#predecessors">predecessors</a></li><li><a href="global.html#predecessorsUntil">predecessorsUntil</a></li><li><a href="global.html#predecessorsUpTo">predecessorsUpTo</a></li><li><a href="global.html#query">query</a></li><li><a href="global.html#realizeEdgesForNode">realizeEdgesForNode</a></li><li><a href="global.html#references">references</a></li><li><a href="global.html#removeComponent">removeComponent</a></li><li><a href="global.html#removeEdge">removeEdge</a></li><li><a href="global.html#removeMetaKey">removeMetaKey</a></li><li><a href="global.html#removeNode">removeNode</a></li><li><a href="global.html#removeNodeMetaKey">removeNodeMetaKey</a></li><li><a href="global.html#rePath">rePath</a></li><li><a href="global.html#replaceByCall">replaceByCall</a></li><li><a href="global.html#replaceByThunk">replaceByThunk</a></li><li><a href="global.html#replaceNode">replaceNode</a></li><li><a href="global.html#replacePort">replacePort</a></li><li><a href="global.html#sameParents">sameParents</a></li><li><a href="global.html#sameParentsNodes">sameParentsNodes</a></li><li><a href="global.html#sequential">sequential</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setMeta">setMeta</a></li><li><a href="global.html#setMetaKey">setMetaKey</a></li><li><a href="global.html#setNodeMeta">setNodeMeta</a></li><li><a href="global.html#setNodeMetaKey">setNodeMetaKey</a></li><li><a href="global.html#setPortName">setPortName</a></li><li><a href="global.html#successors">successors</a></li><li><a href="global.html#toJSON">toJSON</a></li><li><a href="global.html#unCompound">unCompound</a></li><li><a href="global.html#updateComponent">updateComponent</a></li><li><a href="global.html#updateEdge">updateEdge</a></li><li><a href="global.html#updateMetaKey">updateMetaKey</a></li><li><a href="global.html#updateNode">updateNode</a></li><li><a href="global.html#updateNodeMetaKey">updateNodeMetaKey</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Apr 20 2017 22:15:44 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
